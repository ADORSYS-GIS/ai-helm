{{- if .Values.controllers.cronjob.enabled }}
{{- include "keycloak-backup.validateValues" . -}}
{{- $cronjob := .Values.controllers.cronjob -}}
{{- $root := . -}}

apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "keycloak-backup.cronjobName" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "keycloak-backup.labels" . | nindent 4 }}
    {{- if $cronjob.labels }}
    {{- toYaml $cronjob.labels | nindent 4 }}
    {{- end }}
  annotations:
    {{- if $cronjob.annotations }}
    {{- toYaml $cronjob.annotations | nindent 4 }}
    {{- end }}
    description: "Scheduled Keycloak configuration backup job"
spec:
  schedule: {{ $cronjob.schedule | quote }}
  successfulJobsHistoryLimit: {{ $cronjob.successfulJobsHistoryLimit | default 3 }}
  failedJobsHistoryLimit: {{ $cronjob.failedJobsHistoryLimit | default 3 }}
  concurrencyPolicy: {{ $cronjob.concurrencyPolicy | default "Forbid" }}
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: quay.io/keycloak/keycloak:24.0
              env:
                - name: KEYCLOAK_ADMIN
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.keycloak.secretName }}
                      key: username
                - name: KEYCLOAK_ADMIN_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.keycloak.secretName }}
                      key: password
                - name: KC_HOSTNAME
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.keycloak.secretName }}
                      key: hostname
                - name: S3_BUCKET
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.s3.secretName }}
                      key: S3_BUCKET_NAME
                - name: S3_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.s3.secretName }}
                      key: S3_ACCESS_KEY_ID
                - name: S3_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.s3.secretName }}
                      key: S3_SECRET_ACCESS_KEY
                - name: S3_REGION
                  valueFrom:
                    secretKeyRef:
                      name: {{ $root.Values.s3.secretName }}
                      key: S3_REGION_NAME
                - name: BACKUP_PREFIX
                  value: {{ $root.Values.keycloak.realm | default "" }}
              command:
                - /bin/sh
                - -c
                - |
                  # Wait for Keycloak to be ready
                  echo "Waiting for Keycloak to be ready..."
                  until curl -sf http://${KC_HOSTNAME}:8080/health/ready > /dev/null 2>&1 || curl -sf http://localhost:8080/health/ready > /dev/null 2>&1; do
                    sleep 5
                  done
                  echo "Keycloak is ready!"
                  
                  # Login to Keycloak admin
                  echo "Logging in to Keycloak admin..."
                  export KEYCLOAK_TOKEN=$(curl -s -X POST http://${KC_HOSTNAME}:8080/realms/master/protocol/openid-connect/token \
                    -H "Content-Type: application/x-www-form-urlencoded" \
                    -d "username=${KEYCLOAK_ADMIN}" \
                    -d "password=${KEYCLOAK_ADMIN_PASSWORD}" \
                    -d "grant_type=password" \
                    -d "client_id=admin-cli" | jq -r '.access_token')
                  
                  if [ -z "$KEYCLOAK_TOKEN" ] || [ "$KEYCLOAK_TOKEN" = "null" ]; then
                    echo "Failed to get Keycloak token"
                    exit 1
                  fi
                  
                  TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
                  
                  {{- if .Values.keycloak.realm }}
                  # Backup specific realm
                  REALM="{{ .Values.keycloak.realm }}"
                  echo "Exporting realm: $REALM"
                  BACKUP_FILE="${REALM}_${TIMESTAMP}.json.gz"
                  
                  curl -s -X GET "http://${KC_HOSTNAME}:8080/admin/realms/${REALM}" \
                    -H "Authorization: Bearer $KEYCLOAK_TOKEN" | gzip > /tmp/$BACKUP_FILE
                  
                  if [ -n "{{ $root.Values.s3.prefix }}" ]; then
                    aws s3 cp /tmp/$BACKUP_FILE s3://{{ $root.Values.s3.secretName }}/{{ $root.Values.s3.prefix }}/$BACKUP_FILE
                  else
                    aws s3 cp /tmp/$BACKUP_FILE s3://${S3_BUCKET}/$BACKUP_FILE
                  fi
                  
                  echo "Exported and uploaded: $BACKUP_FILE"
                  rm -f /tmp/$BACKUP_FILE
                  
                  {{- else }}
                  # Backup all realms
                  echo "Getting list of realms..."
                  REALMS=$(curl -s -X GET "http://${KC_HOSTNAME}:8080/admin/realms" \
                    -H "Authorization: Bearer $KEYCLOAK_TOKEN" | jq -r '.[].realm')
                  
                  for REALM in $REALMS; do
                    echo "Exporting realm: $REALM"
                    BACKUP_FILE="${REALM}_${TIMESTAMP}.json.gz"
                    
                    curl -s -X GET "http://${KC_HOSTNAME}:8080/admin/realms/${REALM}" \
                      -H "Authorization: Bearer $KEYCLOAK_TOKEN" | gzip > /tmp/$BACKUP_FILE
                    
                    if [ -n "{{ $root.Values.s3.prefix }}" ]; then
                      aws s3 cp /tmp/$BACKUP_FILE s3://{{ $root.Values.s3.secretName }}/{{ $root.Values.s3.prefix }}/$BACKUP_FILE
                    else
                      aws s3 cp /tmp/$BACKUP_FILE s3://${S3_BUCKET}/$BACKUP_FILE
                    fi
                    
                    echo "Exported and uploaded: $BACKUP_FILE"
                    rm -f /tmp/$BACKUP_FILE
                  done
                  {{- end }}
                  
                  echo "Backup completed successfully!"
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: true
                capabilities:
                  drop:
                    - ALL
          restartPolicy: OnFailure
{{- end }}
